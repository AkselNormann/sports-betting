#!/usr/bin/env python3

"""
Update the training data.
"""

from os import linesep
from argparse import ArgumentParser

import pandas as pd
from sklearn.linear_model import LogisticRegression
from sklearn.dummy import DummyClassifier
from imblearn.pipeline import make_pipeline
from sklearnext.over_sampling import SMOTE
from sportsbet.soccer import BettingAgent


def parse_args():
    """Parse command line arguments."""
    
    # Create parser
    parser = ArgumentParser('Backtest a classifier multiple times.')
    
    # Add arguments
    parser.add_argument('--classifier', default='random', help='The classifier to predict the results.')
    parser.add_argument('--num-runs', default=5, type=int, help='Number of backtesting repetitions.')
    parser.add_argument('--predicted-result', default='A', help='Predicted result (H or A or D).')
    parser.add_argument('--test-year', default=2, type=int, help='Test year (2 or 3).')
    parser.add_argument('--max-day-range', default=6, type=int, help='Maximum day range between bets.')
    parser.add_argument('--bet-factor', default=1.5, type=float, help='Factor to multiple betting amount in the case of loss.')  
    parser.add_argument('--credit-exponent', default=3, type=int, help='Exponent to raise bet factor. Returns the available credit.')
      
    return parser.parse_args()


def apply_backtest(classifier, num_runs, predicted_result, test_year, max_day_range):

    # Define estimator
    if classifier == 'random':
        classifier = DummyClassifier()
        params = ['random_state']
    elif classifier == 'baseline':
        classifier = make_pipeline(SMOTE(), LogisticRegression(solver='lbfgs'))
        params = ['smote__random_state', 'logisticregression__random_state']

    # Backtest
    betting_agents = []
    for random_state in range(num_runs):
        classifier.set_params(**{param: random_state for param in params})
        betting_agent = BettingAgent()
        betting_agent.backtest(classifier, None, predicted_result, test_year, max_day_range)
        betting_agents.append(betting_agent)
    
    return betting_agents


def print_results(betting_agents):
    """Print the backtestings results"""

    # Parse results
    results = []
    for betting_agent in betting_agents:
        statistics = betting_agent.calculate_backtest_stats(args['bet_factor'], args['credit_exponent'])
        results.append((statistics['Capital'].values[-1], betting_agent.precision_, betting_agent.profit_per_bet_))
    
    # Print results
    results = pd.DataFrame(results, columns=['Capital', 'Precision', 'Profit per bet'])
    msgs = (u'Average capital: {:.1f}', u'Average precision: {:.1f}% ', u'Average profit per bet: {:.1f}% ')
    aggregated_results = zip(results.mean().values, results.std().values, msgs)
    two_lines = 2 * linesep
    for ind, (avg_val, std_val, msg) in enumerate(aggregated_results):
        if len(results) == 1:
            if ind == 0:
                print(linesep, statistics, end=two_lines)
            else:
                avg_val *= 100
            std_val = ''
        else:
            if ind == 0:
                msg = linesep + msg + ' \xb1 {:.1f}'
            else:
                avg_val *= 100
                std_val *= 100
                msg += ' \xb1 {:.1f}%'
        print(msg.format(avg_val, std_val))



if __name__ == '__main__':
    
    # Parse arguments
    args = vars(parse_args())
    
    # Backtesting
    betting_agents = apply_backtest(args['classifier'], args['num_runs'], args['predicted_result'], args['test_year'], args['max_day_range'])
    
    # Print results
    print_results(betting_agents)

    
